<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>AssistGo - Mapa</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    .high-contrast {
      background-color: #000000 !important;
      color: #ffffff !important;
    }
    .high-contrast-header {
      background-color: #111827 !important;
      border-color: #ffffff !important;
    }
    .high-contrast-nav {
      background-color: #111827 !important;
      border-color: #ffffff !important;
    }
    .high-contrast-accent {
      color: #4ade80 !important;
    }

    /* ====== ESTILOS DEL WIDGET DE GOOGLE COMMUTES ====== */

    html,
    body {
      height: 100%;
      margin: 0;
      padding: 0;
    }

    .commutes {
      align-content: stretch;
      color: #202124;
      display: flex;
      flex-direction: column;
      flex-wrap: wrap;
      font-family: Arial, sans-serif;
      height: 480px;
      min-height: 256px;
      min-width: 360px;
      overflow: auto;
      width: 100%;
      border-radius: 8px;
      border: 1px solid #e5e7eb;
    }

    .commutes-info {
      flex: 0 0 auto;
      max-width: 100%;
      overflow: visible;
      padding: 8px 16px 16px;
      background: #ffffff;
    }

    .commutes-initial-state {
      border-radius: 8px;
      border: 1px solid #dadce0;
      display: flex;
      height: 98px;
      margin-top: 8px;
      padding: 0 16px;
    }

    .commutes-initial-state svg {
      align-self: center;
    }

    .commutes-initial-state .description {
      align-self: center;
      flex-grow: 1;
      padding: 0 16px;
    }

    .commutes-initial-state .description .heading {
      font: 22px/28px Arial, sans-serif;
      margin: 0;
    }

    .commutes-initial-state .description p {
      color: #5f6368;
      font: 13px/20px Arial, sans-serif;
      margin: 0;
    }

    .commutes-initial-state .add-button {
      align-self: center;
      background-color: #1a73e8;
      border-color: #1a73e8;
      border-radius: 4px;
      border-style: solid;
      color: #fff;
      cursor: pointer;
      display: inline-flex;
      fill: #fff;
      padding: 8px 16px 8px 8px;
      white-space: nowrap;
    }

    .commutes-initial-state .add-button .label {
      font: normal 600 15px/24px Arial, sans-serif;
      padding-left: 8px;
    }

    @media (max-width: 535px) {
      .commutes-initial-state svg {
        display: none;
      }

      .commutes-initial-state .description {
        padding-left: 0;
      }

      .commutes-initial-state .description .heading {
        font-weight: bold;
        font-size: 15px;
        line-height: 24px;
      }
    }

    .commutes-destinations {
      display: none;
      position: relative;
      width: 100%;
    }

    .commutes-destinations:hover .visible {
      display: block;
    }

    .commutes-destinations .destinations-container {
      display: flex;
      overflow-x: auto;
      padding: 8px 8px 4px 8px;
      white-space: nowrap;
      width: 100%;
    }

    .commutes-destinations .destinations-container::-webkit-scrollbar {
      display: none;
    }

    .commutes-destinations .destination-list {
      display: flex;
      flex-grow: 1;
    }

    .commutes-destinations .right-control,
    .commutes-destinations .left-control {
      background-color: #fff;
      border-radius: 40px;
      border-style: none;
      bottom: 35px;
      box-shadow: 0 2px 3px 0 rgb(60 64 67 / 30%), 0 6px 10px 4px rgb(60 64 67 / 15%);
      cursor: pointer;
      fill: #616161;
      height: 40px;
      padding: 8px;
      position: absolute;
      width: 40px;
      z-index: 100;
    }

    .commutes-destinations .right-control:hover,
    .commutes-destinations .left-control:hover {
      background-color: #f1f3f4;
    }

    .commutes-destinations .left-control {
      left: 16px;
    }

    .commutes-destinations .right-control {
      right: 16px;
    }

    .commutes-destinations .add-button {
      align-items: center;
      background-color: #e8f0fe;
      border-radius: 8px;
      border-color: #e8f0fe;
      border-style: solid;
      color: #1967d2;
      cursor: pointer;
      display: flex;
      fill: #1967d2;
      flex-direction: column;
      flex-grow: 1;
      font-weight: bold;
      gap: 4px;
      justify-content: center;
      min-width: 156px;
      padding: 20px 16px;
    }

    .commutes-destinations .add-button:hover {
      background-color: #d2e3fc;
      border-color: #d2e3fc;
      color: #185abc;
      fill: #185abc;
    }

    .commutes-destinations .destination-container {
      cursor: pointer;
      display: flex;
      flex: 1 1 0;
      position: relative;
    }

    .commutes-destinations .destination {
      border-radius: 4px;
      box-shadow: 0 1px 2px 0 rgba(60, 64, 67, 0.3), 0 1px 3px 1px rgba(60, 64, 67, 0.15);
      color: #5f6368;
      fill: #5f6368;
      height: 72px;
      justify-content: space-between;
      margin-right: 8px;
      min-width: 256px;
      overflow: hidden;
      padding: 12px;
      position: relative;
      width: 100%;
      background: #ffffff;
    }

    .commutes-destinations .active:after {
      background-color: #4285f4;
      content: '';
      display: block;
      height: 4px;
      left: 0;
      position: absolute;
      top: 0;
      width: 100%;
    }

    .commutes-destinations .active + .destination-controls .directions-button {
      fill: #4285f4;
    }

    .commutes-destinations .active + .destination-controls .edit-button {
      opacity: 1;
    }

    .commutes-destinations .active .metadata .location-marker {
      background-color: #fce8e6;
      color: #d93025;
    }

    .commutes-destinations .destination-container:hover,
    .commutes-destinations .destination-container:focus-within {
      background-color: #f8f9fa;
    }

    .commutes-destinations .destination-container:hover .edit-button,
    .commutes-destinations .destination-container:focus-within .edit-button {
      opacity: 1;
    }

    .commutes-destinations .destination .destination-content {
      font-size: 12px;
      line-height: 20px;
      overflow: hidden;
    }

    .commutes-destinations .destination .metadata {
      align-items: center;
      display: flex;
      margin-bottom: 4px;
      gap: 4px;
    }

    .commutes-destinations .destination-container svg {
      height: 18px;
      width: 18px;
    }

    .commutes-destinations .destination .location-marker {
      background-color: #f1f3f4;
      border-radius: 8px;
      color: #616161;
      display: inline-block;
      font-size: 14px;
      font-weight: bold;
      line-height: 16px;
      text-align: center;
      width: 16px;
    }

    .commutes-destinations .destination .address {
      margin-bottom: 4px;
      max-width: 100%;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .commutes-destinations .destination .address abbr {
      text-decoration: none;
    }

    .commutes-destinations .destination .destination-eta {
      color: #202124;
      font-weight: bold;
      font-size: 22px;
      line-height: 28px;
    }

    .commutes-destinations .destination-container .destination-controls {
      align-items: flex-end;
      display: flex;
      flex-direction: column;
      min-width: 70px;
      position: absolute;
      right: 20px;
      text-align: right;
      top: 12px;
      white-space: nowrap;
    }

    .commutes-destinations .destination-container .directions-button {
      align-items: center;
      background-color: #fff;
      border-radius: 32px;
      border: 1px solid #dadce0;
      cursor: pointer;
      display: flex;
      fill: #5f6368;
      height: 32px;
      justify-content: center;
      margin: 0;
      width: 34px;
    }

    .commutes-destinations .destination-container .directions-button:hover {
      background-color: #e8f0fe;
      fill: #4285f4;
    }

    .commutes-destinations .destination-container .edit-button {
      background-color: #fff;
      border-radius: 20px;
      border: 1px solid #dadce0;
      opacity: 0;
      font-size: 14px;
      font-weight: bold;
      line-height: 22px;
      margin: 8px 0 0 0;
      padding: 3px 12px 3px 5px;
      fill: #616161;
      color: #616161;
      cursor: pointer;
    }

    .commutes-destinations .destination-container .edit-button svg {
      display: inline-block;
      font-size: 20px;
      line-height: 20px;
      width: 20px;
      vertical-align: middle;
    }

    .commutes-destinations .destination-container .edit-button:hover {
      background-color: #f1f3f4;
    }

    .commutes-map {
      flex: 1;
      overflow: hidden;
      position: relative;
      width: 100%;
      min-height: 240px;
    }

    .commutes-map .map-view {
      background-color: rgb(229, 227, 223);
      height: 100%;
      left: 0;
      position: absolute;
      top: 0;
      width: 100%;
    }

    .commutes-modal-container {
      align-items: center;
      background-color: rgba(0, 0, 0, 0.4);
      display: none;
      height: 100%;
      justify-content: center;
      left: 0;
      position: fixed;
      top: 0;
      width: 100%;
      z-index: 1000;
    }

    .commutes-modal {
      background: #fff;
      border-radius: 4px;
      box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.2),
        0 4px 5px rgba(0, 0, 0, 0.14), 0 1px 10px rgba(0, 0, 0, 0.12);
      height: 256px;
      position: absolute;
      width: 360px;
    }

    .commutes-modal .content {
      padding: 24px 24px 8px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .commutes-modal .heading {
      font: 24px/32px Arial, sans-serif;
      margin: 0;
    }

    .commutes-modal input {
      font: 16px/24px Arial, sans-serif;
      padding: 10px;
      box-sizing: border-box;
      width: 100%;
    }

    .commutes-modal .error {
      background-color: #fce4e4;
      border: 1px solid #c03;
    }

    .commutes-modal .error-message {
      color: #c03;
      display: inline-block;
      font: 12px/14px Arial, sans-serif;
      margin: 0 0 5px;
    }

    .commutes-modal .travel-modes {
      display: flex;
      flex-direction: row;
      height: 40px;
      margin-bottom: 12px;
      padding: 0;
      width: 100%;
    }

    .commutes-modal .travel-modes [type='radio'] {
      height: 0;
      opacity: 0;
      position: absolute;
      width: 0;
    }

    .commutes-modal .travel-modes label {
      align-items: center;
      border: solid #dadce0;
      border-width: 1px 0.031em;
      cursor: pointer;
      display: inline-flex;
      fill: #5f6368;
      flex: 1;
      justify-content: center;
      padding: 6px;
      position: relative;
      transition: background 0.5s, fill 0.5s;
    }

    .commutes-modal .travel-modes label:hover {
      background-color: #f1f3f4;
    }

    .commutes-modal .travel-modes svg {
      height: 24px;
      width: 24px;
    }

    .commutes-modal .travel-modes .left-label {
      border-left-width: 1px;
      border-radius: 4px 0 0 4px;
    }

    .commutes-modal .travel-modes .right-label {
      border-radius: 0 4px 4px 0;
      border-right-width: 1px;
    }

    .commutes-modal .travel-modes input[type='radio']:checked + label {
      background: #e8f0fe;
      fill: #1967d2;
    }

    .commutes-modal .travel-modes input[type='radio']:focus-visible + label {
      outline: 2px solid Highlight;
      outline: 2px solid -webkit-focus-ring-color;
      outline-offset: -2px;
    }

    .commutes-modal .modal-action-bar {
      display: flex;
      justify-content: flex-end;
    }

    .commutes-modal .modal-action-bar button {
      background: #ffff;
      border: none;
      cursor: pointer;
      font-size: 14px;
      font-weight: bold;
      line-height: 32px;
    }

    .commutes-modal .modal-action-bar .delete-destination-button {
      color: #c5221f;
      left: 18px;
      position: absolute;
    }

    .commutes-modal .modal-action-bar .cancel-button {
      color: #0000008a;
    }

    .commutes-modal .modal-action-bar .add-destination-button,
    .commutes-modal .modal-action-bar .edit-destination-button {
      color: #1a73e8;
    }

    .hide {
      display: none;
    }
  </style>
</head>
<body class="min-h-screen bg-gray-50 text-black">

  <!-- Sprite SVG -->
  <svg xmlns="http://www.w3.org/2000/svg" style="display:none">
    <symbol id="icon-home" viewBox="0 0 24 24">
      <path d="M12 3 3 10h2v9h5v-6h4v6h5v-9h2z" />
    </symbol>
    <symbol id="icon-map" viewBox="0 0 24 24">
      <path d="M9 3 4 5v16l5-2 6 2 5-2V3l-5 2-6-2zm0 2.47 6 2v13.06l-6-2.01V5.47zm-2 .06v13.06l-2 1V6.53l2-1zm12 0v13.06l-2 1V6.53l2-1z" />
    </symbol>
    <symbol id="icon-history" viewBox="0 0 24 24">
      <path d="M13 3a9 9 0 1 0 8.94 8H20A7 7 0 1 1 13 5V3zm-1 4v6h5v-2h-3V7h-2z" />
    </symbol>
    <symbol id="icon-settings" viewBox="0 0 24 24">
      <path d="M19.14 12.94c.04-.31.06-.63.06-.94s-.02-.63-.06-.94l2.03-1.58a.5.5 0 0 0 .12-.64l-1.92-3.32a.5.5 0 0 0-.61-.22l-2.39.96a7.14 7.14 0 0 0-1.63-.94L14.4 2.5a.5.5 0 0 0-.49-.5h-3.82a.5.5 0 0 0-.49.5l-.36 2.82a7.14 7.14 0 0 0-1.63.94l-2.39-.96a.5.5 0 0 0-.61.22L2.7 8.86a.5.5 0 0 0 .12.64l2.03 1.58c-.04.31-.06.63-.06.94s.02.63.06.94L2.82 14.54a.5.5 0 0 0-.12.64l1.92 3.32c.13.22.39.31.61.22l2.39-.96c.5.38 1.05.7 1.63.94l.36 2.82c.03.25.24.44.49.44h3.82c.25 0 .46-.19.49-.44l.36-2.82c.58-.24 1.13-.56 1.63-.94l2.39.96c.23.09.48 0 .61-.22l1.92-3.32a.5.5 0 0 0-.12-.64l-2.03-1.58zM12 15a3 3 0 1 1 0-6 3 3 0 0 1 0 6z" />
    </symbol>
    <symbol id="icon-alert" viewBox="0 0 24 24">
      <path d="M1 21h22L12 2 1 21zm12-3h-2v2h2v-2zm0-6h-2v4h2v-4z" />
    </symbol>
  </svg>

  <!-- Header -->
  <header
  id="header"
  class="bg-white border-b border-gray-200 sticky top-0 z-30"
>
  <div class="flex items-center justify-between px-4 py-4">
    <!-- Botón menú lateral -->
    <button
      class="p-2 mr-2 rounded hover:bg-gray-100"
      aria-label="Abrir menú de navegación"
      onclick="openSideMenu()"
    >
      <!-- Ícono hamburguesa simple -->
      <svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" stroke="currentColor">
        <path d="M4 7h16M4 12h16M4 17h16" stroke-width="2" stroke-linecap="round"/>
      </svg>
    </button>

    <h1 class="text-xl flex-1">
      <span class="font-medium">Uber</span>
      <span id="brand-accent" class="text-green-600"> Accesible</span>
    </h1>

    <!-- El botón que ya tenías de alto contraste se queda -->
    <button
      class="p-3 rounded hover:bg-gray-100"
      aria-label="Alternar alto contraste"
      onclick="toggleHighContrast()"
    >
      <span id="alert-icon" class="text-yellow-600 text-2xl">
        <svg class="w-6 h-6" viewBox="0 0 24 24" fill="currentColor">
          <use href="#icon-alert" />
        </svg>
      </span>
    </button>
  </div>
</header>

<!-- Overlay del menú -->
<div
  id="side-menu-overlay"
  class="fixed inset-0 bg-black/40 z-40 hidden"
  onclick="closeSideMenu()"
></div>

<!-- Menú lateral -->
<aside
  id="side-menu"
  class="fixed top-0 left-0 h-full w-64 bg-white shadow-lg z-50 -translate-x-full transform transition-transform duration-200"
  aria-label="Menú de navegación"
>
  <div class="p-4 border-b">
    <h2 class="text-lg font-semibold">Menú de navegación</h2>
    <p class="text-sm text-gray-500">Seleccione una opción para navegar</p>
  </div>

  <nav class="p-4 space-y-6">
    <!-- Inicio -->
    <a
      href="home.html"
      class="flex items-center gap-3 text-gray-800 hover:text-green-600"
      onclick="closeSideMenu()"
    >
      <svg class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor">
        <use href="#icon-home" />
      </svg>
      <span>Inicio</span>
    </a>

    <!-- Ver mapa -->
    <a
      href="map.html"
      class="flex items-center gap-3 text-gray-800 hover:text-green-600"
      onclick="closeSideMenu()"
    >
      <svg class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor">
        <use href="#icon-map" />
      </svg>
      <span>Ver mapa</span>
    </a>

    <!-- Historial -->
    <a
      href="history.html"
      class="flex items-center gap-3 text-gray-800 hover:text-green-600"
      onclick="closeSideMenu()"
    >
      <svg class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor">
        <use href="#icon-history" />
      </svg>
      <span>Historial</span>
    </a>

    <!-- Modo alto contraste -->
    <button
      type="button"
      class="flex items-center gap-3 text-gray-800 hover:text-green-600 w-full text-left"
      onclick="toggleHighContrast(); closeSideMenu();"
    >
      <svg class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor">
        <use href="#icon-settings" />
      </svg>
      <span>Modo alto contraste</span>
    </button>
  </nav>
</aside>


  <main class="pb-24 max-w-4xl mx-auto pt-4 px-4">
    <h2 class="text-2xl font-semibold mb-2">Mapa</h2>
    <p class="text-gray-600 mb-4">
      Aquí puedes ver el mapa y estimar tiempos de traslado hacia destinos frecuentes.
    </p>

    <!-- Resumen del viaje capturado en Home -->
    <div id="trip-summary" class="mb-4 hidden border border-gray-200 rounded-lg p-3 bg-white text-sm">
      <h3 class="font-semibold mb-1">Viaje solicitado</h3>
      <p><span class="font-medium">Origen:</span> <span id="trip-origin"></span></p>
      <p><span class="font-medium">Destino:</span> <span id="trip-destination"></span></p>
    </div>

    <!-- Widget Commutes -->
    <!-- SVGs ocultos del widget -->
    <!-- (todo el bloque de SVGs del widget se deja igual que en tu archivo original) -->

    <!-- SVGs ocultos del widget -->
    <!-- ... (los <svg class="hide"> con los símbolos se quedan tal cual, omitidos aquí por espacio) -->

    <!-- PONGO TODO EL BLOQUE ORIGINAL DE SVGs, SIN CAMBIOS -->
    <!-- (Para no hacerlo infinito aquí: en tu archivo real conserva exactamente los <svg class="hide"> que ya tenías) -->

    <!-- BEGIN: SVGs ocultos del widget (ID iguales a tu archivo) -->
    <!-- *** copia aquí exactamente los SVGs de tu archivo original (commutes-initial-icon, add-icon, driving-icon, etc.) *** -->
    <!-- END: SVGs ocultos del widget -->

    <!-- Como el archivo original ya está cargado arriba en tu entorno, mantén esos SVGs sin cambio -->

    <div class="commutes" aria-label="Commutes widget">
      <div class="commutes-map" aria-label="Map">
        <div class="map-view"></div>
      </div>

      <div class="commutes-info">
        <div class="commutes-initial-state">
          <svg
            aria-label="Directions Icon"
            width="53"
            height="53"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
          >
            <use href="#commutes-initial-icon" />
          </svg>
          <div class="description">
            <h1 class="heading">Estimate commute time</h1>
            <p>See travel time and directions for places nearby</p>
          </div>
          <button class="add-button" autofocus>
            <svg
              aria-label="Add Icon"
              width="24px"
              height="24px"
              xmlns="http://www.w3.org/2000/svg"
            >
              <use href="#commutes-add-icon" />
            </svg>
            <span class="label">Add destination</span>
          </button>
        </div>

        <div class="commutes-destinations">
          <div class="destinations-container">
            <div class="destination-list"></div>
            <button class="add-button">
              <svg
                aria-label="Add Icon"
                width="24px"
                height="24px"
                xmlns="http://www.w3.org/2000/svg"
              >
                <use href="#commutes-add-icon" />
              </svg>
              <div class="label">Add destination</div>
            </button>
          </div>
          <button
            class="left-control hide"
            data-direction="-1"
            aria-label="Scroll left"
          >
            <svg
              width="24px"
              height="24px"
              xmlns="http://www.w3.org/2000/svg"
              data-direction="-1"
            >
              <use
                href="#commutes-chevron-left-icon"
                data-direction="-1"
              />
            </svg>
          </button>
          <button
            class="right-control hide"
            data-direction="1"
            aria-label="Scroll right"
          >
            <svg
              width="24px"
              height="24px"
              xmlns="http://www.w3.org/2000/svg"
              data-direction="1"
            >
              <use
                href="#commutes-chevron-right-icon"
                data-direction="1"
              />
            </svg>
          </button>
        </div>
      </div>
    </div>

    <div class="commutes-modal-container">
      <div
        class="commutes-modal"
        role="dialog"
        aria-modal="true"
        aria-labelledby="add-edit-heading"
      >
        <div class="content">
          <h2 id="add-edit-heading" class="heading">Add destination</h2>
          <form id="destination-form" name="destination-form">
            <input
              type="text"
              id="destination-address-input"
              name="destination-address"
              placeholder="Enter a place or address"
              autocomplete="off"
              required
            />
            <div class="error-message" role="alert"></div>
            <div class="travel-modes">
              <input
                type="radio"
                name="travel-mode"
                id="driving-mode"
                value="DRIVING"
                aria-label="Driving travel mode"
              />
              <label
                for="driving-mode"
                class="left-label"
                title="Driving travel mode"
              >
                <svg
                  aria-label="Driving icon"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <use href="#commutes-driving-icon" />
                </svg>
              </label>
              <input
                type="radio"
                name="travel-mode"
                id="transit-mode"
                value="TRANSIT"
                aria-label="Public transit travel mode"
              />
              <label
                for="transit-mode"
                title="Public transit travel mode"
              >
                <svg
                  aria-label="Public transit icon"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <use href="#commutes-transit-icon" />
                </svg>
              </label>
              <input
                type="radio"
                name="travel-mode"
                id="bicycling-mode"
                value="BICYCLING"
                aria-label="Bicycling travel mode"
              />
              <label
                for="bicycling-mode"
                title="Bicycling travel mode"
              >
                <svg
                  aria-label="Bicycling icon"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <use href="#commutes-bicycling-icon" />
                </svg>
              </label>
              <input
                type="radio"
                name="travel-mode"
                id="walking-mode"
                value="WALKING"
                aria-label="Walking travel mode"
              />
              <label
                for="walking-mode"
                class="right-label"
                title="Walking travel mode"
              >
                <svg
                  aria-label="Walking icon"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <use href="#commutes-walking-icon" />
                </svg>
              </label>
            </div>
          </form>
          <div class="modal-action-bar">
            <button
              class="delete-destination-button hide"
              type="reset"
            >
              Delete
            </button>
            <button class="cancel-button" type="reset">
              Cancel
            </button>
            <button
              class="add-destination-button"
              type="button"
            >
              Add
            </button>
            <button
              class="edit-destination-button hide"
              type="button"
            >
              Done
            </button>
          </div>
        </div>
      </div>
    </div>
  </main>

  <!-- Bottom nav -->
  <nav
    id="bottom-nav"
    class="fixed bottom-0 left-0 right-0 bg-white border-t border-gray-200"
  >
    <div class="flex items-center justify-around py-2">
      <a
        href="home.html"
        class="flex flex-col items-center gap-1 h-auto py-3 px-4 text-xs text-gray-600"
      >
        <svg class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor">
          <use href="#icon-home" />
        </svg>
        <span>Inicio</span>
      </a>
      <a
        href="map.html"
        class="flex flex-col items-center gap-1 h-auto py-3 px-4 text-xs text-green-600"
      >
        <svg class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor">
          <use href="#icon-map" />
        </svg>
        <span>Mapa</span>
      </a>
      <a
        href="history.html"
        class="flex flex-col items-center gap-1 h-auto py-3 px-4 text-xs text-gray-600"
      >
        <svg class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor">
          <use href="#icon-history" />
        </svg>
        <span>Historial</span>
      </a>
    </div>
  </nav>

  <script>
    // Redirección si no está autenticado
    if (localStorage.getItem("isAuthenticated") !== "true") {
      window.location.href = "index.html";
    }

    function toggleHighContrast() {
      const body = document.body;
      const header = document.getElementById("header");
      const bottomNav = document.getElementById("bottom-nav");
      const brandAccent = document.getElementById("brand-accent");
      const alertIcon = document.getElementById("alert-icon");

      const enable = !body.classList.contains("high-contrast");

      body.classList.toggle("high-contrast", enable);
      header.classList.toggle("high-contrast-header", enable);
      bottomNav.classList.toggle("high-contrast-nav", enable);
      if (brandAccent) brandAccent.classList.toggle("high-contrast-accent", enable);
      if (alertIcon) alertIcon.classList.toggle("text-yellow-400", enable);
    }
  </script>

  <!-- SCRIPT COMMUTES -->
  <script>
    "use strict";

    const commutesEl = {
      map: document.querySelector(".map-view"),
      initialStatePanel: document.querySelector(".commutes-initial-state"),
      destinationPanel: document.querySelector(".commutes-destinations"),
      modal: document.querySelector(".commutes-modal-container"),
    };

    const destinationPanelEl = {
      addButton: commutesEl.destinationPanel.querySelector(".add-button"),
      container: commutesEl.destinationPanel.querySelector(
        ".destinations-container"
      ),
      list: commutesEl.destinationPanel.querySelector(".destination-list"),
      scrollLeftButton: commutesEl.destinationPanel.querySelector(
        ".left-control"
      ),
      scrollRightButton: commutesEl.destinationPanel.querySelector(
        ".right-control"
      ),
      getActiveDestination: () =>
        commutesEl.destinationPanel.querySelector(".destination.active"),
    };

    const destinationModalEl = {
      title: commutesEl.modal.querySelector("h2"),
      form: commutesEl.modal.querySelector("form"),
      destinationInput: commutesEl.modal.querySelector(
        'input[name="destination-address"]'
      ),
      errorMessage: commutesEl.modal.querySelector(".error-message"),
      addButton: commutesEl.modal.querySelector(".add-destination-button"),
      deleteButton: commutesEl.modal.querySelector(
        ".delete-destination-button"
      ),
      editButton: commutesEl.modal.querySelector(".edit-destination-button"),
      cancelButton: commutesEl.modal.querySelector(".cancel-button"),
      getTravelModeInput: () =>
        commutesEl.modal.querySelector('input[name="travel-mode"]:checked'),
    };

    const MAX_NUM_DESTINATIONS = 10;
    const BIAS_BOUND_DISTANCE = 0.5;
    const HOUR_IN_SECONDS = 3600;
    const MIN_IN_SECONDS = 60;

    const STROKE_COLORS = {
      active: { innerStroke: "#4285F4", outerStroke: "#185ABC" },
      inactive: { innerStroke: "#BDC1C6", outerStroke: "#80868B" },
    };

    const MARKER_ICON_COLORS = {
      active: { fill: "#EA4335", stroke: "#C5221F", label: "#FFF" },
      inactive: { fill: "#F1F3F4", stroke: "#9AA0A6", label: "#3C4043" },
    };

    const DestinationOperation = { ADD: "ADD", EDIT: "EDIT", DELETE: "DELETE" };

    const TravelMode = {
      DRIVING: "DRIVING",
      TRANSIT: "TRANSIT",
      BICYCLING: "BICYCLING",
      WALKING: "WALKING",
    };

    function Commutes(configuration) {
      let commutesMap;
      let activeDestinationIndex;
      let origin = configuration.mapOptions.center;
      let destinations = configuration.destination || [];
      let markerIndex = 0;
      let lastActiveEl;

      const markerIconConfig = {
        path: "M10 27c-.2 0-.2 0-.5-1-.3-.8-.7-2-1.6-3.5-1-1.5-2-2.7-3-3.8-2.2-2.8-3.9-5-3.9-8.8C1 4.9 5 1 10 1s9 4 9 8.9c0 3.9-1.8 6-4 8.8-1 1.2-1.9 2.4-2.8 3.8-1 1.5-1.4 2.7-1.6 3.5-.3 1-.4 1-.6 1Z",
        fillOpacity: 1,
        strokeWeight: 1,
        anchor: new google.maps.Point(15, 29),
        scale: 1.2,
        labelOrigin: new google.maps.Point(10, 9),
      };
      const originMarkerIcon = {
        ...markerIconConfig,
        fillColor: MARKER_ICON_COLORS.active.fill,
        strokeColor: MARKER_ICON_COLORS.active.stroke,
      };
      const destinationMarkerIcon = {
        ...markerIconConfig,
        fillColor: MARKER_ICON_COLORS.inactive.fill,
        strokeColor: MARKER_ICON_COLORS.inactive.stroke,
      };
      const bikeLayer = new google.maps.BicyclingLayer();
      const publicTransitLayer = new google.maps.TransitLayer();

      initMapView();
      initDestinations();
      initCommutesPanel();
      initCommutesModal();

      function initMapView() {
        const mapOptionConfig = configuration.mapOptions;
        commutesMap = new google.maps.Map(commutesEl.map, mapOptionConfig);

        configuration.defaultTravelModeEnum =
          parseTravelModeEnum(configuration.defaultTravelMode);
        setTravelModeLayer(configuration.defaultTravelModeEnum);
        createMarker(origin);
      }

      function initDestinations() {
        if (!configuration.initialDestinations) return;
        let callbackCounter = 0;
        const placesService = new google.maps.places.PlacesService(
          commutesMap
        );
        for (const destination of configuration.initialDestinations) {
          destination.travelModeEnum = parseTravelModeEnum(
            destination.travelMode
          );
          const label = getNextMarkerLabel();
          const request = {
            placeId: destination.placeId,
            fields: ["place_id", "geometry", "name"],
          };
          placesService.getDetails(
            request,
            function (place) {
              if (!place.geometry || !place.geometry.location) return;
              const travelModeEnum =
                destination.travelModeEnum ||
                configuration.defaultTravelModeEnum;
              const destinationConfig = createDestinationConfig(
                place,
                travelModeEnum,
                label
              );
              getDirections(destinationConfig).then((response) => {
                if (!response) return;
                destinations.push(destinationConfig);
                getCommutesInfo(response, destinationConfig);
                callbackCounter++;
                if (
                  callbackCounter ===
                  configuration.initialDestinations.length
                ) {
                  destinations.sort(function (a, b) {
                    return a.label < b.label ? -1 : 1;
                  });
                  let bounds = new google.maps.LatLngBounds();
                  for (let i = 0; i < destinations.length; i++) {
                    assignMapObjectListeners(destinations[i], i);
                    updateCommutesPanel(
                      destinations[i],
                      i,
                      DestinationOperation.ADD
                    );
                    bounds.union(destinations[i].bounds);
                  }
                  const lastIndex = destinations.length - 1;
                  handleRouteClick(destinations[lastIndex], lastIndex);
                  commutesMap.fitBounds(bounds);
                }
              });
            },
            () => {
              console.error("Failed to retrieve places info");
            }
          );
        }
      }

      function initCommutesPanel() {
        const addCommutesButtonEls =
          document.querySelectorAll(".add-button");
        addCommutesButtonEls.forEach((addButton) => {
          addButton.addEventListener("click", () => {
            destinationModalEl.title.innerHTML = "Add destination";
            hideElement(destinationModalEl.deleteButton);
            hideElement(destinationModalEl.editButton);
            showElement(destinationModalEl.addButton);
            showModal();
            const travelModeEnum =
              configuration.defaultTravelModeEnum || TravelMode.DRIVING;
            const travelModeId = travelModeEnum.toLowerCase() + "-mode";
            document.forms["destination-form"][travelModeId].checked = true;
          });
        });

        destinationPanelEl.scrollLeftButton.addEventListener(
          "click",
          handleScrollButtonClick
        );
        destinationPanelEl.scrollRightButton.addEventListener(
          "click",
          handleScrollButtonClick
        );
        destinationPanelEl.list.addEventListener("keydown", (e) => {
          if (
            e.key === "Enter" &&
            e.target !== destinationPanelEl.getActiveDestination()
          ) {
            e.target.click();
            e.preventDefault();
          }
        });
      }

      function initCommutesModal() {
        const boundConfig = {
          north: origin.lat + BIAS_BOUND_DISTANCE,
          south: origin.lat - BIAS_BOUND_DISTANCE,
          east: origin.lng + BIAS_BOUND_DISTANCE,
          west: origin.lng - BIAS_BOUND_DISTANCE,
        };

        const destinationFormReset = function () {
          destinationModalEl.destinationInput.classList.remove("error");
          destinationModalEl.errorMessage.innerHTML = "";
          destinationModalEl.form.reset();
          destinationToAdd = null;
        };

        const autocompleteOptions = {
          bounds: boundConfig,
          fields: ["place_id", "geometry", "name"],
        };
        const autocomplete = new google.maps.places.Autocomplete(
          destinationModalEl.destinationInput,
          autocompleteOptions
        );
        let destinationToAdd;
        autocomplete.addListener("place_changed", () => {
          const place = autocomplete.getPlace();
          if (!place.geometry || !place.geometry.location) {
            return;
          } else {
            destinationToAdd = place;
            destinationModalEl.getTravelModeInput().focus();
          }
          destinationModalEl.destinationInput.classList.remove("error");
          destinationModalEl.errorMessage.innerHTML = "";
        });

        destinationModalEl.addButton.addEventListener("click", () => {
          const isValidInput = validateDestinationInput(destinationToAdd);
          if (!isValidInput) return;
          const selectedTravelMode =
            destinationModalEl.getTravelModeInput().value;
          addDestinationToList(destinationToAdd, selectedTravelMode);
          destinationFormReset();
          hideModal();
        });

        destinationModalEl.editButton.addEventListener("click", () => {
          const destination = { ...destinations[activeDestinationIndex] };
          const selectedTravelMode =
            destinationModalEl.getTravelModeInput().value;
          const isSameDestination =
            destination.name === destinationModalEl.destinationInput.value;
          const isSameTravelMode =
            destination.travelModeEnum === selectedTravelMode;
          if (isSameDestination && isSameTravelMode) {
            hideModal();
            return;
          }
          if (!isSameDestination) {
            const isValidInput = validateDestinationInput(destinationToAdd);
            if (!isValidInput) return;
            destination.name = destinationToAdd.name;
            destination.place_id = destinationToAdd.place_id;
            destination.url = generateMapsUrl(
              destinationToAdd,
              selectedTravelMode
            );
          }
          if (!isSameTravelMode) {
            destination.travelModeEnum = selectedTravelMode;
            destination.url = generateMapsUrl(destination, selectedTravelMode);
          }
          destinationFormReset();
          getDirections(destination)
            .then((response) => {
              if (!response) return;
              const currentIndex = activeDestinationIndex;
              removeDirectionsFromMapView(destination);
              destinations[activeDestinationIndex] = destination;
              getCommutesInfo(response, destination);
              assignMapObjectListeners(destination, activeDestinationIndex);
              updateCommutesPanel(
                destination,
                activeDestinationIndex,
                DestinationOperation.EDIT
              );
              handleRouteClick(destination, activeDestinationIndex);
              const newEditButton = destinationPanelEl.list.children
                .item(activeDestinationIndex)
                .querySelector(".edit-button");
              newEditButton.focus();
            })
            .catch((e) =>
              console.error("Editing directions failed due to " + e)
            );
          hideModal();
        });

        destinationModalEl.cancelButton.addEventListener("click", () => {
          destinationFormReset();
          hideModal();
        });

        destinationModalEl.deleteButton.addEventListener("click", () => {
          removeDirectionsFromMapView(
            destinations[activeDestinationIndex]
          );
          updateCommutesPanel(
            destinations[activeDestinationIndex],
            activeDestinationIndex,
            DestinationOperation.DELETE
          );
          activeDestinationIndex = undefined;
          destinationFormReset();
          let elToFocus;
          if (destinations.length) {
            const lastIndex = destinations.length - 1;
            handleRouteClick(destinations[lastIndex], lastIndex);
            elToFocus =
              destinationPanelEl.getActiveDestination();
          } else {
            elToFocus =
              commutesEl.initialStatePanel.querySelector(".add-button");
          }
          hideModal(elToFocus);
        });

        window.onmousedown = function (event) {
          if (event.target === commutesEl.modal) {
            destinationFormReset();
            hideModal();
          }
        };

        commutesEl.modal.addEventListener("keydown", (e) => {
          switch (e.key) {
            case "Enter":
              if (
                e.target === destinationModalEl.cancelButton ||
                e.target === destinationModalEl.deleteButton
              ) {
                return;
              }
              if (destinationModalEl.addButton.style.display !== "none") {
                destinationModalEl.addButton.click();
              } else if (
                destinationModalEl.editButton.style.display !== "none"
              ) {
                destinationModalEl.editButton.click();
              }
              break;
            case "Esc":
            case "Escape":
              hideModal();
              break;
            default:
              return;
          }
          e.preventDefault();
        });

        const firstInteractiveElement = destinationModalEl.destinationInput;
        const lastInteractiveElements = [
          destinationModalEl.addButton,
          destinationModalEl.editButton,
        ];

        firstInteractiveElement.addEventListener(
          "keydown",
          handleFirstInteractiveElementTab
        );
        for (const el of lastInteractiveElements) {
          el.addEventListener("keydown", handleLastInteractiveElementTab);
        }

        function handleFirstInteractiveElementTab(event) {
          if (event.key === "Tab" && event.shiftKey) {
            for (const el of lastInteractiveElements) {
              if (el.style.display !== "none") {
                event.preventDefault();
                el.focus();
                return;
              }
            }
          }
        }

        function handleLastInteractiveElementTab(event) {
          if (event.key === "Tab" && !event.shiftKey) {
            event.preventDefault();
            firstInteractiveElement.focus();
          }
        }
      }

      function validateDestinationInput(destinationToAdd) {
        let errorMessage;
        let isValidInput = false;
        if (!destinationToAdd) {
          errorMessage = "No details available for destination input";
        } else if (destinations.length > MAX_NUM_DESTINATIONS) {
          errorMessage =
            "Cannot add more than " + MAX_NUM_DESTINATIONS + " destinations";
        } else if (
          destinations &&
          destinations.find(
            (destination) =>
              destination.place_id === destinationToAdd.place_id
          )
        ) {
          errorMessage = "Destination is already added";
        } else {
          isValidInput = true;
        }
        if (!isValidInput) {
          destinationModalEl.errorMessage.innerHTML = errorMessage;
          destinationModalEl.destinationInput.classList.add("error");
        }
        return isValidInput;
      }

      function removeDirectionsFromMapView(destination) {
        destination.polylines.innerStroke.setMap(null);
        destination.polylines.outerStroke.setMap(null);
        destination.marker.setMap(null);
      }

      function buildDestinationCardTemplate(
        destination,
        destinationIdx,
        destinationOperation
      ) {
        let editButtonEl;
        switch (destinationOperation) {
          case DestinationOperation.ADD:
            destinationPanelEl.list.insertAdjacentHTML(
              "beforeend",
              '<div class="destination-container">' +
                generateDestinationTemplate(destination) +
                "</div>"
            );
            const destinationContainerEl =
              destinationPanelEl.list.lastElementChild;
            destinationContainerEl.addEventListener("click", () => {
              handleRouteClick(destination, destinationIdx);
            });
            editButtonEl =
              destinationContainerEl.querySelector(".edit-button");
            destinationPanelEl.container.scrollLeft =
              destinationPanelEl.container.scrollWidth;
            break;
          case DestinationOperation.EDIT:
            const activeDestinationContainerEl =
              destinationPanelEl.getActiveDestination().parentElement;
            activeDestinationContainerEl.innerHTML =
              generateDestinationTemplate(destination);
            activeDestinationContainerEl.addEventListener("click", () => {
              handleRouteClick(destination, destinationIdx);
            });
            editButtonEl =
              activeDestinationContainerEl.querySelector(".edit-button");
            break;
          case DestinationOperation.DELETE:
          default:
        }

        if (editButtonEl) {
          editButtonEl.addEventListener("click", (event) => {
            event.stopPropagation();
            destinationModalEl.title.innerHTML = "Edit destination";
            destinationModalEl.destinationInput.value = destination.name;
            showElement(destinationModalEl.deleteButton);
            showElement(destinationModalEl.editButton);
            hideElement(destinationModalEl.addButton);
            showModal();
            const travelModeId =
              destination.travelModeEnum.toLowerCase() + "-mode";
            document.forms["destination-form"][travelModeId].checked = true;
            destinationModalEl.destinationInput.dispatchEvent(
              new Event("input")
            );
          });
        }
      }

      function updateCommutesPanel(
        destination,
        destinationIdx,
        destinationOperation
      ) {
        switch (destinationOperation) {
          case DestinationOperation.ADD:
            hideElement(commutesEl.initialStatePanel);
            showElement(commutesEl.destinationPanel);
          case DestinationOperation.EDIT:
            buildDestinationCardTemplate(
              destination,
              destinationIdx,
              destinationOperation
            );
            break;
          case DestinationOperation.DELETE:
            destinations.splice(destinationIdx, 1);
            destinationPanelEl.list.innerHTML = "";
            for (let i = 0; i < destinations.length; i++) {
              buildDestinationCardTemplate(
                destinations[i],
                i,
                DestinationOperation.ADD
              );
              assignMapObjectListeners(destinations[i], i);
            }
          default:
        }
        if (!destinations.length) {
          showElement(
            commutesEl.initialStatePanel,
            commutesEl.initialStatePanel
          );
          hideElement(commutesEl.destinationPanel);
          activeDestinationIndex = undefined;
          return;
        }
        destinationPanelEl.container.addEventListener(
          "scroll",
          handlePanelScroll
        );
        destinationPanelEl.container.dispatchEvent(new Event("scroll"));
      }

      function addDestinationToList(destinationToAdd, travelModeEnum) {
        const destinationConfig = createDestinationConfig(
          destinationToAdd,
          travelModeEnum
        );
        const newDestinationIndex = destinations.length;
        getDirections(destinationConfig)
          .then((response) => {
            if (!response) return;
            destinations.push(destinationConfig);
            getCommutesInfo(response, destinationConfig);
            assignMapObjectListeners(destinationConfig, newDestinationIndex);
            updateCommutesPanel(
              destinationConfig,
              newDestinationIndex,
              DestinationOperation.ADD
            );
            handleRouteClick(destinationConfig, newDestinationIndex);
            destinationPanelEl.addButton.focus();
          })
          .catch((e) =>
            console.error("Adding destination failed due to " + e)
          );
      }

      function getNextMarkerLabel() {
        const markerLabels = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        const label = markerLabels[markerIndex];
        markerIndex = (markerIndex + 1) % markerLabels.length;
        return label;
      }

      function createDestinationConfig(
        destinationToAdd,
        travelModeEnum,
        label
      ) {
        return {
          name: destinationToAdd.name,
          place_id: destinationToAdd.place_id,
          label: label || getNextMarkerLabel(),
          travelModeEnum: travelModeEnum,
          url: generateMapsUrl(destinationToAdd, travelModeEnum),
        };
      }

      function getDirections(destination) {
        const request = {
          origin: origin,
          destination: { placeId: destination.place_id },
          travelMode: destination.travelModeEnum,
          unitSystem:
            configuration.distanceMeasurementType === "METRIC"
              ? google.maps.UnitSystem.METRIC
              : google.maps.UnitSystem.IMPERIAL,
        };
        const directionsService = new google.maps.DirectionsService();
        return directionsService.route(request).then((response) => {
          return response;
        });
      }

      function getCommutesInfo(directionResponse, destination) {
        if (!directionResponse) return;
        const path = directionResponse.routes[0].overview_path;
        const bounds = directionResponse.routes[0].bounds;
        const directionLeg = directionResponse.routes[0].legs[0];
        const destinationLocation = directionLeg.end_location;
        const distance = directionLeg.distance.text;
        const duration = convertDurationValueAsString(
          directionLeg.duration.value
        );

        const innerStroke = new google.maps.Polyline({
          path: path,
          strokeColor: STROKE_COLORS.inactive.innerStroke,
          strokeOpacity: 1.0,
          strokeWeight: 3,
          zIndex: 10,
        });

        const outerStroke = new google.maps.Polyline({
          path: path,
          strokeColor: STROKE_COLORS.inactive.outerStroke,
          strokeOpacity: 1.0,
          strokeWeight: 6,
          zIndex: 1,
        });

        const marker = createMarker(destinationLocation, destination.label);

        innerStroke.setMap(commutesMap);
        outerStroke.setMap(commutesMap);

        destination.distance = distance;
        destination.duration = duration;
        destination.marker = marker;
        destination.polylines = { innerStroke, outerStroke };
        destination.bounds = bounds;
      }

      function assignMapObjectListeners(destination, destinationIdx) {
        google.maps.event.clearListeners(destination.marker, "click");

        google.maps.event.addListener(destination.marker, "click", () => {
          handleRouteClick(destination, destinationIdx);
          destinationPanelEl.list
            .querySelectorAll(".destination")
            [destinationIdx].focus();
        });
        google.maps.event.addListener(
          destination.marker,
          "mouseover",
          () => {
            changeMapObjectStrokeWeight(destination, true);
          }
        );
        google.maps.event.addListener(
          destination.marker,
          "mouseout",
          () => {
            changeMapObjectStrokeWeight(destination, false);
          }
        );
        for (const strokeLine in destination.polylines) {
          google.maps.event.clearListeners(
            destination.polylines[strokeLine],
            "click"
          );
          google.maps.event.clearListeners(
            destination.polylines[strokeLine],
            "mouseover"
          );

          google.maps.event.addListener(
            destination.polylines[strokeLine],
            "click",
            () => {
              handleRouteClick(destination, destinationIdx);
              destinationPanelEl.list
                .querySelectorAll(".destination")
                [destinationIdx].focus();
            }
          );
          google.maps.event.addListener(
            destination.polylines[strokeLine],
            "mouseover",
            () => {
              changeMapObjectStrokeWeight(destination, true);
            }
          );
          google.maps.event.addListener(
            destination.polylines[strokeLine],
            "mouseout",
            () => {
              changeMapObjectStrokeWeight(destination, false);
            }
          );
        }
      }

      function generateMapsUrl(destination, travelModeEnum) {
        let googleMapsUrl = "https://www.google.com/maps/dir/?api=1";
        googleMapsUrl += `&origin=${origin.lat},${origin.lng}`;
        googleMapsUrl +=
          "&destination=" +
          encodeURIComponent(destination.name) +
          "&destination_place_id=" +
          destination.place_id;
        googleMapsUrl += "&travelmode=" + travelModeEnum.toLowerCase();
        return googleMapsUrl;
      }

      function changeMapObjectStrokeWeight(destination, mouseOver) {
        const destinationMarkerIcon = destination.marker.icon;
        if (mouseOver) {
          destination.polylines.outerStroke.setOptions({ strokeWeight: 8 });
          destinationMarkerIcon.strokeWeight = 2;
          destination.marker.setIcon(destinationMarkerIcon);
        } else {
          destination.polylines.outerStroke.setOptions({ strokeWeight: 6 });
          destinationMarkerIcon.strokeWeight = 1;
          destination.marker.setIcon(destinationMarkerIcon);
        }
      }

      function handleRouteClick(destination, destinationIdx) {
        if (activeDestinationIndex !== undefined) {
          destinations[
            activeDestinationIndex
          ].polylines.innerStroke.setOptions({
            strokeColor: STROKE_COLORS.inactive.innerStroke,
            zIndex: 2,
          });
          destinations[
            activeDestinationIndex
          ].polylines.outerStroke.setOptions({
            strokeColor: STROKE_COLORS.inactive.outerStroke,
            zIndex: 1,
          });

          destinations[activeDestinationIndex].marker.setIcon(
            destinationMarkerIcon
          );
          destinations[activeDestinationIndex].marker.label.color =
            MARKER_ICON_COLORS.inactive.label;

          const activeDestinationEl =
            destinationPanelEl.getActiveDestination();
          if (activeDestinationEl) {
            activeDestinationEl.classList.remove("active");
          }
        }

        activeDestinationIndex = destinationIdx;

        setTravelModeLayer(destination.travelModeEnum);

        const newDestinationEl = destinationPanelEl.list.querySelectorAll(
          ".destination"
        )[destinationIdx];
        newDestinationEl.classList.add("active");
        newDestinationEl.scrollIntoView({
          behavior: "smooth",
          block: "center",
        });

        destination.polylines.innerStroke.setOptions({
          strokeColor: STROKE_COLORS.active.innerStroke,
          zIndex: 101,
        });
        destination.polylines.outerStroke.setOptions({
          strokeColor: STROKE_COLORS.active.outerStroke,
          zIndex: 99,
        });

        destination.marker.setIcon(originMarkerIcon);
        destination.marker.label.color = "#ffffff";

        commutesMap.fitBounds(destination.bounds);
      }

      function createMarker(location, label) {
        const isOrigin = label === undefined ? true : false;
        const markerIconConfig = isOrigin
          ? originMarkerIcon
          : destinationMarkerIcon;
        const labelColor = isOrigin
          ? MARKER_ICON_COLORS.active.label
          : MARKER_ICON_COLORS.inactive.label;
        const labelText = isOrigin ? "●" : label;

        const mapOptions = {
          position: location,
          map: commutesMap,
          label: {
            text: labelText,
            fontFamily: "Arial, sans-serif",
            color: labelColor,
            fontSize: "16px",
          },
          icon: markerIconConfig,
        };

        if (isOrigin) {
          mapOptions.label.fontSize = "20px";
        }
        const marker = new google.maps.Marker(mapOptions);

        return marker;
      }

      function parseTravelModeEnum(travelModeString) {
        switch (travelModeString) {
          case "DRIVING":
            return TravelMode.DRIVING;
          case "BICYCLING":
            return TravelMode.BICYCLING;
          case "PUBLIC_TRANSIT":
            return TravelMode.TRANSIT;
          case "WALKING":
            return TravelMode.WALKING;
          default:
            return null;
        }
      }

      function setTravelModeLayer(travelModeEnum) {
        switch (travelModeEnum) {
          case TravelMode.BICYCLING:
            publicTransitLayer.setMap(null);
            bikeLayer.setMap(commutesMap);
            break;
          case TravelMode.TRANSIT:
            bikeLayer.setMap(null);
            publicTransitLayer.setMap(commutesMap);
            break;
          default:
            publicTransitLayer.setMap(null);
            bikeLayer.setMap(null);
        }
      }

      function convertDurationValueAsString(durationValue) {
        if (!durationValue) {
          return "";
        }
        if (durationValue < MIN_IN_SECONDS) {
          return "<1 min";
        }
        if (durationValue > HOUR_IN_SECONDS * 10) {
          return "10+ hours";
        }
        const hours = Math.floor(durationValue / HOUR_IN_SECONDS);
        const minutes = Math.floor((durationValue % HOUR_IN_SECONDS) / 60);
        const hoursString = hours > 0 ? hours + " h" : "";
        const minutesString = minutes > 0 ? minutes + " min" : "";
        const spacer = hoursString && minutesString ? " " : "";
        return hoursString + spacer + minutesString;
      }

      function showModal() {
        lastActiveEl = document.activeElement;
        showElement(commutesEl.modal, destinationModalEl.destinationInput);
      }

      function hideModal(focusEl) {
        hideElement(commutesEl.modal, focusEl || lastActiveEl);
      }

      /* === MÉTODO EXTRA PARA USARLO DESDE FUERA (map.html) === */
      this.addDestinationFromPlace = function (place, travelModeString) {
        if (!place || !place.place_id) {
          console.warn("Lugar inválido para destino");
          return;
        }
        const travelModeEnum =
          parseTravelModeEnum(travelModeString) ||
          configuration.defaultTravelModeEnum ||
          TravelMode.DRIVING;

        const label = getNextMarkerLabel();
        const destinationConfig = createDestinationConfig(
          place,
          travelModeEnum,
          label
        );
        const newDestinationIndex = destinations.length;

        getDirections(destinationConfig)
          .then((response) => {
            if (!response) return;
            destinations.push(destinationConfig);
            getCommutesInfo(response, destinationConfig);
            assignMapObjectListeners(destinationConfig, newDestinationIndex);
            updateCommutesPanel(
              destinationConfig,
              newDestinationIndex,
              DestinationOperation.ADD
            );
            handleRouteClick(destinationConfig, newDestinationIndex);
          })
          .catch((e) =>
            console.error("Error al agregar destino desde texto:", e)
          );
      };

      this.setOrigin = function (latLng) {
        if (!latLng) return;
        origin = { lat: latLng.lat(), lng: latLng.lng() };
        commutesMap.setCenter(latLng);
      };
    }

    function hideElement(el, focusEl) {
      el.style.display = "none";
      if (focusEl) focusEl.focus();
    }

    function showElement(el, focusEl) {
      el.style.display = "flex";
      if (focusEl) focusEl.focus();
    }

    function handleScrollButtonClick(e) {
      const multiplier = 1.25;
      const direction = e.target.dataset.direction;
      const cardWidth =
        destinationPanelEl.list.firstElementChild.offsetWidth;

      destinationPanelEl.container.scrollBy({
        left: direction * cardWidth * multiplier,
        behavior: "smooth",
      });
    }

    function handlePanelScroll() {
      const position = destinationPanelEl.container.scrollLeft;
      const scrollWidth = destinationPanelEl.container.scrollWidth;
      const width = destinationPanelEl.container.offsetWidth;

      if (scrollWidth > width) {
        if (position === 0) {
          destinationPanelEl.scrollLeftButton.classList.remove("visible");
        } else {
          destinationPanelEl.scrollLeftButton.classList.add("visible");
        }

        if (Math.ceil(position + width) >= scrollWidth) {
          destinationPanelEl.scrollRightButton.classList.remove("visible");
        } else {
          destinationPanelEl.scrollRightButton.classList.add("visible");
        }
      }
    }

    function generateDestinationTemplate(destination) {
      const travelModeIconTemplate =
        '<use href="#commutes-' +
        destination.travelModeEnum.toLowerCase() +
        '-icon"/>';
      return `
        <div class="destination" tabindex="0" role="button">
          <div class="destination-content">
            <div class="metadata">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                  ${travelModeIconTemplate}
              </svg>
              ${destination.distance}
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                <use href="#commutes-arrow-icon"/>
              </svg>
              <span class="location-marker">${destination.label}</span>
            </div>
            <div class="address">To
              <abbr title="${destination.name}">${destination.name}</abbr>
            </div>
            <div class="destination-eta">${destination.duration}</div>
          </div>
        </div>

        <div class="destination-controls">
          <a class="directions-button" href=${destination.url} target="_blank"
             aria-label="Link to directions in Google Maps">
            <svg aria-label="Directions icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
              <use href="#commutes-directions-icon"/>
            </svg>
          </a>
          <button class="edit-button" aria-label="Edit Destination">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
              <use href="#commutes-edit-icon"/>
            </svg>
            Edit
          </button>
        </div>`;
    }
  </script>

<button
type="button"
onclick="usarMiUbicacion()"
class="w-full bg-gray-200 rounded py-2 mt-2"
>
Usar mi ubicación actual
</button>

<script>
function usarMiUbicacion() {
  if (!("geolocation" in navigator)) {
    alert("Tu navegador no soporta geolocalización.");
    return;
  }

  navigator.geolocation.getCurrentPosition(
    (position) => {
      const { latitude, longitude } = position.coords;

      // Guardas coordenadas en localStorage
      localStorage.setItem("originLat", latitude);
      localStorage.setItem("originLng", longitude);

      // Opcional: marca el campo de texto para que el usuario sepa qué pasó
      const originInput = document.getElementById("origin-input");
      if (originInput) {
        originInput.value = "Mi ubicación actual";
      }

      alert("Ubicación actual guardada como origen.");
    },
    (error) => {
      console.error(error);
      alert("No se pudo obtener tu ubicación.");
    },
    {
      enableHighAccuracy: true,
      timeout: 10000,
    }
  );
}
</script>

  <!-- CONFIG + MAPS -->
  <script>
    let CONFIGURATION = {
      defaultTravelMode: "DRIVING",
      distanceMeasurementType: "METRIC",
      mapOptions: {
        center: { lat: 19.4326, lng: -99.1332 }, // CDMX por defecto
        fullscreenControl: true,
        mapTypeControl: false,
        streetViewControl: false,
        zoom: 12,
        zoomControl: true,
        maxZoom: 20,
        mapId: ""
      },
      mapsApiKey: "AIzaSyBaW30DhxN4pc8U1-Hh25geMWJsjJ1KXLQ"
    };
  
    let commutesInstance = null;
  
    function updateTripSummary(originText, destinationText) {
      const summaryEl = document.getElementById("trip-summary");
      const originEl = document.getElementById("trip-origin");
      const destinationEl = document.getElementById("trip-destination");
  
      if (!summaryEl || !originEl || !destinationEl) return;
  
      if (originText || destinationText) {
        originEl.textContent = originText || "-";
        destinationEl.textContent = destinationText || "-";
        summaryEl.classList.remove("hidden");
      } else {
        summaryEl.classList.add("hidden");
      }
    }
  
    function initMap() {
      const storedOrigin = localStorage.getItem("origin") || "";
      const storedDestination = localStorage.getItem("destination") || "";
  
      // ✅ NUEVO: leer coordenadas guardadas
      const originLat = parseFloat(localStorage.getItem("originLat"));
      const originLng = parseFloat(localStorage.getItem("originLng"));
      const hasOriginCoords =
        !isNaN(originLat) && !isNaN(originLng);
  
      updateTripSummary(storedOrigin, storedDestination);
  
      const geocoder = new google.maps.Geocoder();
  
      // 👉 1) Si hay coordenadas de origen, las usamos directo
      if (hasOriginCoords) {
        CONFIGURATION.mapOptions.center = {
          lat: originLat,
          lng: originLng
        };
  
        // Creamos Commutes con ese origen
        commutesInstance = new Commutes(CONFIGURATION);
  
        // Si quieres reforzar origen dentro de Commutes (si tienes this.setOrigin):
        if (typeof commutesInstance.setOrigin === "function") {
          commutesInstance.setOrigin(
            new google.maps.LatLng(originLat, originLng)
          );
        }
  
        // Si hay destino por texto, lo buscamos
        if (storedDestination) {
          addDestinationFromText(storedDestination);
        }
      } else {
        // 👉 2) Si NO hay coordenadas, usamos tu flujo actual: geocodificar el texto
        if (storedOrigin) {
          geocoder.geocode({ address: storedOrigin }, (results, status) => {
            if (
              status === "OK" &&
              results[0] &&
              results[0].geometry &&
              results[0].geometry.location
            ) {
              const loc = results[0].geometry.location;
              CONFIGURATION.mapOptions.center = {
                lat: loc.lat(),
                lng: loc.lng()
              };
            } else {
              console.warn(
                "No se pudo geocodificar el origen, se usa centro por defecto."
              );
            }
  
            commutesInstance = new Commutes(CONFIGURATION);
  
            if (storedOrigin && results[0] && results[0].geometry &&
                typeof commutesInstance.setOrigin === "function") {
              commutesInstance.setOrigin(results[0].geometry.location);
            }
  
            if (storedDestination) {
              addDestinationFromText(storedDestination);
            }
          });
        } else {
          // Sin origen, centro por defecto (CDMX)
          commutesInstance = new Commutes(CONFIGURATION);
          if (storedDestination) {
            addDestinationFromText(storedDestination);
          }
        }
      }
  
      function addDestinationFromText(text) {
        if (!text || !commutesInstance) return;
  
        const service = new google.maps.places.PlacesService(commutesEl.map);
        const center = CONFIGURATION.mapOptions.center;
  
        const request = {
          query: text,
          location: new google.maps.LatLng(center.lat, center.lng),
          radius: 10000
        };
  
        service.textSearch(request, (results, status) => {
          if (
            status === google.maps.places.PlacesServiceStatus.OK &&
            results[0]
          ) {
            commutesInstance.addDestinationFromPlace(
              results[0],
              CONFIGURATION.defaultTravelMode
            );
          } else {
            console.warn("No se encontró destino para:", text);
          }
        });
      }
    }
  </script>

<script>
  function openSideMenu() {
    const menu = document.getElementById("side-menu");
    const overlay = document.getElementById("side-menu-overlay");
    if (!menu || !overlay) return;

    menu.classList.remove("-translate-x-full");
    overlay.classList.remove("hidden");
  }

  function closeSideMenu() {
    const menu = document.getElementById("side-menu");
    const overlay = document.getElementById("side-menu-overlay");
    if (!menu || !overlay) return;

    menu.classList.add("-translate-x-full");
    overlay.classList.add("hidden");
  }
</script>


  <script
    src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBaW30DhxN4pc8U1-Hh25geMWJsjJ1KXLQ&callback=initMap&libraries=places,geometry&language=es&region=MX"
    async
    defer
  ></script>


</body>
</html>